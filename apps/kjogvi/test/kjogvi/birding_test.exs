defmodule Kjogvi.BirdingTest do
  use Kjogvi.DataCase, async: true

  import Kjogvi.UsersFixtures

  alias Kjogvi.Birding
  alias Kjogvi.Birding.Card

  describe "find_new_checklists/2" do
    test "returns unreported checklists" do
      user = user_fixture()
      insert(:card, user: user, ebird_id: "S100803884")
      insert(:card, user: user, ebird_id: "S100803921")

      new_checklists = [%{ebird_id: "S100878702"}, %{ebird_id: "S100803921"}]

      assert Birding.find_new_checklists(user, new_checklists) ==
               [%{ebird_id: "S100878702"}]
    end
  end

  describe "create_card/2" do
    test "creates a card with valid attributes" do
      user = user_fixture()
      location = insert(:location)

      attrs = %{
        "observ_date" => "2024-05-10",
        "location_id" => location.id,
        "effort_type" => "STATIONARY"
      }

      assert {:ok, card} = Birding.create_card(user, attrs)
      assert card.user_id == user.id
      assert card.observ_date == ~D[2024-05-10]
      assert card.effort_type == "STATIONARY"
      assert card.location_id == location.id
    end

    test "returns error changeset with invalid attributes" do
      user = user_fixture()

      assert {:error, changeset} = Birding.create_card(user, %{})
      refute changeset.valid?
    end

    test "creates a card with observations" do
      user = user_fixture()
      location = insert(:location)

      attrs = %{
        "observ_date" => "2024-05-10",
        "location_id" => location.id,
        "effort_type" => "STATIONARY",
        "observations" => %{
          "0" => %{"taxon_key" => "ebird/eBird_2023/bkcchi1", "quantity" => "3"}
        }
      }

      assert {:ok, card} = Birding.create_card(user, attrs)
      card = Repo.preload(card, :observations)
      assert length(card.observations) == 1
      assert hd(card.observations).taxon_key == "ebird/eBird_2023/bkcchi1"
      assert hd(card.observations).quantity == "3"
    end
  end

  describe "update_card/2" do
    test "updates a card with valid attributes" do
      user = user_fixture()
      card = insert(:card, user: user)

      assert {:ok, updated} = Birding.update_card(card, %{"effort_type" => "TRAVEL"})
      assert updated.effort_type == "TRAVEL"
    end

    test "returns error changeset with invalid attributes" do
      user = user_fixture()
      card = insert(:card, user: user)

      assert {:error, changeset} = Birding.update_card(card, %{"observ_date" => nil})
      refute changeset.valid?
    end
  end

  describe "change_card/1" do
    test "returns a changeset for a card" do
      user = user_fixture()
      card = insert(:card, user: user)

      changeset = Birding.change_card(card)
      assert %Ecto.Changeset{} = changeset
    end

    test "applies given attrs to the changeset" do
      user = user_fixture()
      card = insert(:card, user: user)

      changeset = Birding.change_card(card, %{"notes" => "Updated note"})
      assert Ecto.Changeset.get_change(changeset, :notes) == "Updated note"
    end
  end

  describe "new_card/1" do
    test "returns a new card struct for the user" do
      user = user_fixture()

      card = Birding.new_card(user)
      assert %Card{} = card
      assert card.user_id == user.id
      assert card.motorless == false
      assert card.legacy_autogenerated == false
      assert card.resolved == false
      assert card.observations == []
    end
  end

  describe "new_observation/0" do
    test "returns a new observation with defaults" do
      obs = Birding.new_observation()
      assert %Kjogvi.Birding.Observation{} = obs
      assert obs.voice == false
      assert obs.hidden == false
      assert obs.unreported == false
    end
  end

  describe "get_cards/2" do
    test "returns paginated cards for a user" do
      user = user_fixture()
      insert(:card, user: user, observ_date: ~D[2024-01-15])
      insert(:card, user: user, observ_date: ~D[2024-02-20])

      page = Birding.get_cards(user, %{page: 1, page_size: 10})
      assert length(page.entries) == 2
    end

    test "does not return cards from other users" do
      user = user_fixture()
      other_user = user_fixture()
      insert(:card, user: user)
      insert(:card, user: other_user)

      page = Birding.get_cards(user, %{page: 1, page_size: 10})
      assert length(page.entries) == 1
    end

    test "orders cards by date descending" do
      user = user_fixture()
      insert(:card, user: user, observ_date: ~D[2024-01-15])
      insert(:card, user: user, observ_date: ~D[2024-03-20])
      insert(:card, user: user, observ_date: ~D[2024-02-10])

      page = Birding.get_cards(user, %{page: 1, page_size: 10})
      dates = Enum.map(page.entries, & &1.observ_date)
      assert dates == [~D[2024-03-20], ~D[2024-02-10], ~D[2024-01-15]]
    end

    test "includes observation count" do
      user = user_fixture()
      card = insert(:card, user: user)
      insert(:observation, card: card, taxon_key: "ebird/eBird_2023/bkcchi1")
      insert(:observation, card: card, taxon_key: "ebird/eBird_2023/amecro")

      page = Birding.get_cards(user, %{page: 1, page_size: 10})
      assert hd(page.entries).observation_count == 2
    end

    test "paginates results" do
      user = user_fixture()

      for i <- 1..5 do
        insert(:card, user: user, observ_date: Date.add(~D[2024-01-01], i))
      end

      page = Birding.get_cards(user, %{page: 1, page_size: 2})
      assert length(page.entries) == 2
      assert page.total_entries == 5
    end
  end

  describe "fetch_card_with_observations/2" do
    test "returns a card with preloaded observations for the user" do
      user = user_fixture()
      {taxon, _} = Kjogvi.Factory.create_species_taxon_with_page()
      card = insert(:card, user: user)
      insert(:observation, card: card, taxon_key: Ornitho.Schema.Taxon.key(taxon))

      fetched = Birding.fetch_card_with_observations(user, card.id)
      assert fetched.id == card.id
      assert length(fetched.observations) == 1
    end

    test "raises when card belongs to another user" do
      user = user_fixture()
      other_user = user_fixture()
      card = insert(:card, user: other_user)

      assert_raise Ecto.NoResultsError, fn ->
        Birding.fetch_card_with_observations(user, card.id)
      end
    end

    test "raises when card does not exist" do
      user = user_fixture()

      assert_raise Ecto.NoResultsError, fn ->
        Birding.fetch_card_with_observations(user, -1)
      end
    end
  end

  describe "fetch_card_for_edit/2" do
    test "returns a card with preloaded observations" do
      user = user_fixture()
      card = insert(:card, user: user)
      insert(:observation, card: card, taxon_key: "ebird/eBird_2023/bkcchi1")

      fetched = Birding.fetch_card_for_edit(user, card.id)
      assert fetched.id == card.id
      assert length(fetched.observations) == 1
    end

    test "raises when card belongs to another user" do
      user = user_fixture()
      other_user = user_fixture()
      card = insert(:card, user: other_user)

      assert_raise Ecto.NoResultsError, fn ->
        Birding.fetch_card_for_edit(user, card.id)
      end
    end
  end
end
